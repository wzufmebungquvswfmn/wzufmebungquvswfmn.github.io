# 多线程并发
本节主要汇总一些rust中多线程相关的知识点
1. 线程管理
## std::thread::spawn(func)
spawn用于开辟一个新的子线程，这个子线程用来执行其内部的闭包函数func，其中func: FnOnce() -> ……，这意味着func不应带参数
同时，它会返回一个`JoinHandle<T>`类型的变量，其中 T 是func返回值的类型，在子线程运行结束后才可以被获取到  

## JoinHandle<T>::join()
join()用来等待JoinHandle<T>的值被拿到，并输出Ok(T)  
但是如果子线程执行过程中发生panic!，显然就等不到JoinHandle<T>了，此时join()会返回一个Err(e), e是错误子线程崩溃的错误信息

## move
如果spawn(func)里的func是普通的闭包，那么其会遵循最小特权原则对捕获变量进行借用，但是子线程的存活时间是不一定的，因此spawn要求func的借用必须是'static，否则就会报错；  
为了避免这种情况发生，需要在func前加上move，他会将捕获的变量以和函数传入参数同样的方式进行copy或move，例如对于i32，他会Copy一份新的i32数据供子线程使用，而对于String，他会直接把所有权转移到子线程内部，主线程将不能再使用。

2. 共享状态
## std::sync::Arc<T>
到目前为止，子线程还无法和主线程或其它子线程共享数据，因为数据要么被Copy要么被Move。  
为了能够共享一份数据，需用Arc::new()将T类型的数据包裹起来得到Arc<T>,它相当于为数据开了后门，让T可以在多个地方同时拥有所有权，同时给数据旁边添加了一个计数器，每多一个变量拥有它的所有权计数器就加一，它的安全性由Arc的原子性保证；
对于得到的Arc<T>类型变量,可以直接当作T类型的变量使用，而使用Arc::clone(&var: Arc<T>)能够克隆一份同样是Arc<T>类型的、拥有数据所有权的变量，同时该数据的计数器加一，下面是一个例子：
```rust
use std::thread;
use std::sync::Arc;

fn main() {
    let s = Arc::new(String::from("123"));  // 创建Arc<String>,同时为数据创建计数器
    
    for _ in 0..5 {
        let s_clone = Arc::clone(&s);    // Arc<String>的所有权被共享给新变量，计数器加一；同时它等价于s.clone();
        thread::spawn(move || {
            println!("{s_clone:?}");    //s_clone: Arc<String>的使用与String相同
        });
    }
}
```
尽管如此，Arc<T>只能实现共享读，对于共享写，需要使用锁

## std:sync::Mutex<T>、Mutex<T>.lock()、MutexGuard<'a, T>
Mutex<T>相当于把T类型的数据装进Mutex这个盒子里，一个线程只有成功打开了Mutex，该线程才能对数据进行改写；
Mutex<T>::lock()就是那个开锁/上锁的工具，它会阻塞等待，显然开锁成功后数据又会被立即上锁；
Mutex<T>::lock()后的返回值是Result<MutexGuard<'a, T>, PoisonError>，其中MutexGuard<'a, T>能够实现对数据进行监控，从而实现自动释放锁，使得锁可以被其它线程打开。
```rust
use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    let s = Arc::new(Mutex::new(String::from("Hello!")));    // 经典的Arc<Mutex<T>>结构
    let mut handles = Vec::new();
    for _ in 0..5 {
        let s_clone = Arc::clone(s);
        let handle = thread::spawn(move || {
            let s_guard = s_clone.lock().unwrap();  // 阻塞等待拿锁
            let s_rev = (*s_guard).chars().rev().collect(); // 这里s_guard解引用得到原字符串
            // let s_rev = s_guard.chars().rev().collect(); 自动解引用也可以达到同样的效果
            println!("{s_rev:?}");
        }); //自动释放锁
        
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```
## std::sync::RwLock<T>, RwLock<T>::{read(),write()}
与Mutex一样是为了实现共享数据的读写，但是它把lock拆成了read和write两部分，对读写有着不同的处理：
### 有人在读 (Read Lock)：
其他想读的人：直接放行。于是内存里可以同时存在无数个“只读中间人”。  
其他想写的人：原地等待。必须等所有读的人都走了，才能进去。
### 有人在写 (Write Lock)：
无论是想读还是想写的人：全部等待。  
**简而言之，一个线程的写与其它线程的读写都互斥**

至此，我们实现了对数据的共享读写

3. 消息传递
``rust推崇：“不要通过共享内存来通信，而要通过通信来共享内存”``
## std::sync::mpsc::{channel(), Receiver, Sender }, Receiver::recv(), Sender::send()
mpsc::channel<T>()可以创建一个频道并返回一个二元组(sender<T>, receiver<T>)
Sender<T>::clone(&sender)克隆可以克隆出多个消息发送入口，并且只有所有发送入口都drop()后迭代才能结束
Sender<T>::send(var)会把var放进消息流水线上，var的所有权也被转移
Receiver<T>即消息接收者，不能克隆，只能有一个接收端
Receiver<T>::recv()用来接收消息并存储，它是阻塞的
Receiver<T>::try_recv()是非阻塞的，有消息就接受
iter() / into_iter() 可以用来代替for用以循环接收消息
```rust
//……
fn main() {
    let (tx, rx) = mpsc::channel<i32>();
   
   for i in 0..5 {
       let tx_clone = tx.clone();
       thread::spawn(move || {
          tx_clone.send(i).unwrap(); 
       });  // tx_clone自动drop(); 
   } 
   drop(tx);   //只有tx都drop了，主线程里的for循环流程才会结束
   for msg in rx {
       println!("{msg}");
   }
}
```

4. Send和Sync：决定线程间数据传递的标签
## Send
具有Send Trait的类型数据可以实现线程之间的所有权转移
## Sync
具有Sync Trait的类型数据的引用可以被多个线程共享  

T 是 Sync <==> &T 是 Send
